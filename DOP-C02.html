<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-lang-key="pageTitle">Simulador de Examen AWS DevOps Professional (DOP-C02)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .option-label.correct {
            background-color: #166534; /* green-800 */
            border-color: #22c55e; /* green-500 */
            color: white;
        }
        .option-label.incorrect {
            background-color: #991b1b; /* red-800 */
            border-color: #ef4444; /* red-500 */
            color: white;
        }
        .explanation-card {
            background-color: #374151; /* gray-700 */
            border-left-width: 4px;
        }
        .correct-explanation {
            border-left-color: #22c55e; /* green-500 */
        }
        .incorrect-explanation {
            border-left-color: #ef4444; /* red-500 */
        }
        /* Custom radio button styles */
        .custom-radio-label {
            transition: all 0.2s ease-in-out;
        }
        .custom-radio:checked + .custom-radio-label {
            background-color: #2563eb; /* blue-600 */
            border-color: #3b82f6; /* blue-500 */
            color: white;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 flex items-center justify-center min-h-screen p-4">

    <div id="app" class="w-full max-w-4xl mx-auto">
        
        <div id="start-screen" class="text-center">
            <h1 class="text-4xl font-bold text-white mb-4" data-lang-key="mainTitle">Simulador de Examen</h1>
            <h2 class="text-2xl font-semibold text-blue-400 mb-8">AWS Certified DevOps Engineer - Professional (DOP-C02)</h2>
            
            <!-- Settings -->
            <div class="max-w-md mx-auto bg-gray-800 p-6 rounded-xl shadow-lg mb-8">
                <div class="mb-6">
                    <h3 class="font-semibold text-lg text-white mb-3" data-lang-key="languageLabel">Idioma</h3>
                    <div class="flex justify-center gap-4">
                        <input type="radio" id="lang-es" name="language" value="es" class="hidden custom-radio" checked>
                        <label for="lang-es" class="custom-radio-label cursor-pointer py-2 px-6 border-2 border-gray-600 rounded-lg">Español</label>
                        
                        <input type="radio" id="lang-en" name="language" value="en" class="hidden custom-radio">
                        <label for="lang-en" class="custom-radio-label cursor-pointer py-2 px-6 border-2 border-gray-600 rounded-lg">English</label>
                    </div>
                </div>
                <div>
                    <h3 class="font-semibold text-lg text-white mb-3" data-lang-key="questionCountLabel">Número de Preguntas</h3>
                    <div class="flex justify-center gap-4">
                        <input type="radio" id="count-25" name="question-count" value="25" class="hidden custom-radio" checked>
                        <label for="count-25" class="custom-radio-label cursor-pointer py-2 px-6 border-2 border-gray-600 rounded-lg">25</label>
                        
                        <input type="radio" id="count-50" name="question-count" value="50" class="hidden custom-radio">
                        <label for="count-50" class="custom-radio-label cursor-pointer py-2 px-6 border-2 border-gray-600 rounded-lg">50</label>

                        <input type="radio" id="count-70" name="question-count" value="70" class="hidden custom-radio">
                        <label for="count-70" class="custom-radio-label cursor-pointer py-2 px-6 border-2 border-gray-600 rounded-lg">70</label>
                    </div>
                </div>
            </div>

            <button id="start-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-lg text-xl shadow-lg transition-transform transform hover:scale-105" data-lang-key="startButton">
                Iniciar Examen
            </button>
        </div>

        <div id="quiz-screen" class="hidden">
            <div class="bg-gray-800 p-6 sm:p-8 rounded-xl shadow-2xl">
                <!-- Header -->
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-xl font-bold text-blue-400">
                        <span data-lang-key="questionHeader">Pregunta</span> <span id="question-number"></span> <span data-lang-key="ofHeader">de</span> <span id="total-questions"></span>
                    </h2>
                    <div class="text-lg font-semibold"><span data-lang-key="scoreHeader">Puntuación</span>: <span id="score">0</span></div>
                </div>

                <!-- Question -->
                <div id="question-container" class="mb-6">
                    <p id="question-text" class="text-lg leading-relaxed text-white"></p>
                </div>

                <!-- Options -->
                <div id="options-container" class="space-y-4"></div>

                <!-- Controls -->
                <div class="mt-8 flex flex-col sm:flex-row gap-4">
                    <button id="submit-button" class="w-full sm:w-auto bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg transition duration-300 ease-in-out disabled:bg-gray-600 disabled:cursor-not-allowed" data-lang-key="submitButton">
                        Revisar Respuesta
                    </button>
                    <button id="next-button" class="w-full sm:w-auto bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-6 rounded-lg transition duration-300 ease-in-out hidden" data-lang-key="nextButton">
                        Siguiente Pregunta
                    </button>
                </div>

                 <!-- Explanation -->
                <div id="explanation-section" class="hidden mt-8 space-y-6">
                    <!-- Diagram Image -->
                    <div id="explanation-image-container" class="my-6 hidden">
                        <h4 class="font-bold text-gray-300 mb-3" data-lang-key="diagramHeader">Diagrama Relevante</h4>
                        <img id="explanation-image" src="" alt="Diagrama de la documentación de AWS" class="w-full h-auto rounded-lg border-2 border-gray-600 bg-white p-2">
                    </div>
                    <!-- Justification Text -->
                    <div>
                        <h3 class="text-xl font-bold mb-4 text-white" data-lang-key="justificationHeader">Justificación</h3>
                        <div id="correct-explanation-card" class="explanation-card correct-explanation p-4 rounded-lg">
                            <h4 class="font-bold text-green-400 mb-2" data-lang-key="correctAnswerHeader">Respuesta Correcta:</h4>
                            <p id="explanation-text" class="text-gray-300"></p>
                        </div>
                    </div>
                    <div id="incorrect-explanations-container">
                        <h4 class="font-bold text-red-400 mb-2" data-lang-key="incorrectAnalysisHeader">Análisis de las Opciones Incorrectas:</h4>
                    </div>
                    <div class="mt-4">
                        <a id="doc-link" href="#" target="_blank" rel="noopener noreferrer" class="text-blue-400 hover:text-blue-300 hover:underline font-semibold">
                            <span data-lang-key="docLink">Consultar Documentación Oficial de AWS</span>
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"></path></svg>
                        </a>
                    </div>
                </div>
            </div>
        </div>

        <div id="result-screen" class="hidden text-center bg-gray-800 p-8 rounded-xl shadow-2xl">
            <h1 class="text-4xl font-bold text-white mb-4" data-lang-key="resultsTitle">¡Examen Finalizado!</h1>
            <p class="text-2xl text-gray-300 mb-2" data-lang-key="resultsSubtitle">Tu puntuación final es:</p>
            <p id="final-score" class="text-6xl font-extrabold text-blue-400 mb-8"></p>
            <div id="score-feedback" class="text-lg mb-8"></div>
            <button id="restart-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-lg text-xl shadow-lg transition-transform transform hover:scale-105" data-lang-key="restartButton">
                Intentar de Nuevo
            </button>
        </div>
    </div>

    <script>
        // --- INTERNATIONALIZATION (i18n) STRINGS ---
        const uiStrings = {
            pageTitle: { es: "Simulador de Examen AWS DevOps Professional (DOP-C02)", en: "AWS DevOps Professional Exam Simulator (DOP-C02)" },
            mainTitle: { es: "Simulador de Examen", en: "Exam Simulator" },
            languageLabel: { es: "Idioma", en: "Language" },
            questionCountLabel: { es: "Número de Preguntas", en: "Number of Questions" },
            startButton: { es: "Iniciar Examen", en: "Start Exam" },
            questionHeader: { es: "Pregunta", en: "Question" },
            ofHeader: { es: "de", en: "of" },
            scoreHeader: { es: "Puntuación", en: "Score" },
            submitButton: { es: "Revisar Respuesta", en: "Check Answer" },
            nextButton: { es: "Siguiente Pregunta", en: "Next Question" },
            justificationHeader: { es: "Justificación", en: "Justification" },
            correctAnswerHeader: { es: "Respuesta Correcta:", en: "Correct Answer:" },
            incorrectAnalysisHeader: { es: "Análisis de las Opciones Incorrectas:", en: "Analysis of Incorrect Options:" },
            incorrectOptionHeader: { es: "Opción", en: "Option" },
            docLink: { es: "Consultar Documentación Oficial de AWS", en: "Consult Official AWS Documentation" },
            diagramHeader: { es: "Diagrama Relevante", en: "Relevant Diagram" },
            imageAlt: { es: "Diagrama de la documentación de AWS que ilustra el concepto.", en: "Diagram from AWS documentation illustrating the concept." },
            resultsTitle: { es: "¡Examen Finalizado!", en: "Exam Finished!" },
            resultsSubtitle: { es: "Tu puntuación final es:", en: "Your final score is:" },
            restartButton: { es: "Intentar de Nuevo", en: "Try Again" },
            feedback_good: { es: "¡Excelente trabajo! Estás muy bien preparado para el examen real.", en: "Excellent work! You are very well prepared for the real exam." },
            feedback_medium: { es: "¡Buen esfuerzo! Sigue estudiando las áreas donde fallaste y lo conseguirás.", en: "Good effort! Keep studying the areas you missed, and you will succeed." },
            feedback_bad: { es: "Necesitas repasar más a fondo los conceptos. ¡No te rindas, revisa las explicaciones y vuelve a intentarlo!", en: "You need to review the concepts more thoroughly. Don't give up, review the explanations and try again!" }
        };

        // --- ADVANCED QUESTION BANK (DOP-C02 Level) ---
        const allQuestions = [
            {
                question: {
                    es: "Una empresa despliega microservicios en Amazon ECS con Fargate. Necesitan implementar despliegues canary automatizados. El proceso debe enviar el 10% del tráfico a la nueva versión durante 15 minutos. Si las alarmas de CloudWatch para errores 5xx y latencia P90 no se activan en ese período, el 100% del tráfico debe ser redirigido a la nueva versión. Si cualquier alarma se activa, el despliegue debe revertirse inmediatamente. ¿Cuál es la implementación más eficiente y automatizada?",
                    en: "A company deploys microservices on Amazon ECS with Fargate. They need to implement automated canary deployments. The process must send 10% of traffic to the new version for 15 minutes. If CloudWatch alarms for 5xx errors and P90 latency are not triggered in that period, 100% of traffic should be redirected to the new version. If any alarm triggers, the deployment must roll back immediately. What is the most efficient and automated implementation?"
                },
                options: {
                    es: [
                        "Usar CodeDeploy con una configuración de despliegue Blue/Green para ECS. En el AppSpec, definir un hook `AfterAllowTestTraffic` que invoca una función Lambda. La Lambda espera 15 minutos, comprueba el estado de las alarmas de CloudWatch y luego invoca `ContinueDeployment` o `StopDeployment`.",
                        "Configurar el servicio ECS con dos grupos de destino y usar un script en CodeBuild para cambiar manualmente los pesos del listener del ALB, esperando 15 minutos con un comando `sleep`.",
                        "Usar una acción de aprobación manual en CodePipeline. Un ingeniero revisará manualmente un panel de CloudWatch después de 15 minutos y aprobará o rechazará el despliegue.",
                        "Implementar AWS App Mesh y configurar la política de enrutamiento canary. Usar una función Lambda para consultar las métricas de App Mesh y actualizar la política de enrutamiento."
                    ],
                    en: [
                        "Use CodeDeploy with a Blue/Green deployment configuration for ECS. In the AppSpec, define an `AfterAllowTestTraffic` hook that invokes a Lambda function. The Lambda waits 15 minutes, checks the status of CloudWatch alarms, and then calls `ContinueDeployment` or `StopDeployment`.",
                        "Configure the ECS service with two target groups and use a script in CodeBuild to manually change the ALB listener weights, waiting 15 minutes with a `sleep` command.",
                        "Use a manual approval action in CodePipeline. An engineer will manually review a CloudWatch dashboard after 15 minutes and approve or reject the deployment.",
                        "Implement AWS App Mesh and configure the canary routing policy. Use a Lambda function to query App Mesh metrics and update the routing policy."
                    ]
                },
                correctAnswer: 0,
                explanation: {
                    es: "Esta es la solución canónica de AWS para despliegues canary automatizados y controlados por alarmas. CodeDeploy gestiona el cambio de tráfico de forma segura. El hook `AfterAllowTestTraffic` es el punto exacto para realizar la validación. Una función Lambda es perfecta para la lógica de espera y comprobación de alarmas, proporcionando una automatización completa y un mecanismo de reversión seguro a través de `StopDeployment`.",
                    en: "This is the canonical AWS solution for automated, alarm-controlled canary deployments. CodeDeploy manages the traffic shifting safely. The `AfterAllowTestTraffic` hook is the exact point to perform validation. A Lambda function is perfect for the waiting and alarm-checking logic, providing full automation and a safe rollback mechanism via `StopDeployment`."
                },
                incorrectExplanations: {
                    es: [
                        "Usar `sleep` en CodeBuild es ineficiente, costoso (se factura por el tiempo de compilación) y arriesgado. Si CodeBuild falla, el despliegue queda en un estado intermedio sin un mecanismo de reversión claro.",
                        "Esto no cumple el requisito de ser un proceso automatizado. La intervención manual es propensa a errores y no es escalable.",
                        "Aunque App Mesh soporta canary, es una solución más compleja (service mesh) que no es necesaria si ya se está usando un ALB. La integración directa de CodeDeploy con ALB y CloudWatch es más simple y directa para este caso de uso."
                    ],
                    en: [
                        "Using `sleep` in CodeBuild is inefficient, costly (you are billed for build time), and risky. If CodeBuild fails, the deployment is left in an intermediate state with no clear rollback mechanism.",
                        "This does not meet the requirement for an automated process. Manual intervention is error-prone and not scalable.",
                        "While App Mesh supports canaries, it's a more complex solution (service mesh) that is not necessary if an ALB is already in use. The direct integration of CodeDeploy with ALB and CloudWatch is simpler and more direct for this use case."
                    ]
                },
                link: "https://docs.aws.amazon.com/codedeploy/latest/userguide/deployment-configurations-create.html#deployment-configurations-create-lambda",
                image: "https://docs.aws.amazon.com/codedeploy/latest/userguide/images/ecs-bg-how-it-works-5.png"
            },
            {
                question: {
                    es: "Una organización con docenas de cuentas en AWS Organizations necesita centralizar los logs de CloudTrail y VPC Flow Logs en una única cuenta de Log-Archive. Los logs deben ser inmutables durante 7 años por normativas de cumplimiento. Se debe enviar una alerta en tiempo real a un canal de Slack si se detecta un inicio de sesión de usuario root en cualquier cuenta. ¿Qué arquitectura cumple estos requisitos de la forma más segura y escalable?",
                    en: "An organization with dozens of accounts in AWS Organizations needs to centralize CloudTrail and VPC Flow Logs into a single Log-Archive account. The logs must be immutable for 7 years for compliance regulations. A real-time alert must be sent to a Slack channel if a root user login is detected in any account. Which architecture meets these requirements most securely and scalably?"
                },
                options: {
                    es: [
                        "Habilitar un Trail de Organización en CloudTrail y configurar la publicación de VPC Flow Logs para enviar todo a un bucket S3 centralizado en la cuenta Log-Archive. Habilitar S3 Object Lock en modo Cumplimiento en el bucket con una retención de 7 años. Crear una regla de Amazon EventBridge en la cuenta Log-Archive que filtre por el evento `ConsoleLogin` con `userIdentity.type` como `Root` e invoque una Lambda para enviar la alerta a Slack.",
                        "En cada cuenta miembro, crear un Trail de CloudTrail y una configuración de VPC Flow Logs que apunten al bucket S3 central. Usar una política de bucket para denegar la eliminación de objetos. Configurar un evento de EventBridge en cada cuenta para detectar el login root y enviar un evento a un bus de eventos central.",
                        "Transmitir todos los logs desde cada cuenta a Amazon OpenSearch Service en la cuenta Log-Archive. Configurar una política de retención de 7 años en OpenSearch y usar su función de Alertas para notificar a Slack.",
                        "Usar AWS Control Tower para configurar la gobernanza, lo que crea automáticamente un Trail. Luego, configurar una alarma de CloudWatch en la cuenta de Log-Archive basada en una métrica de un filtro de métricas para el login de root."
                    ],
                    en: [
                        "Enable an Organization Trail in CloudTrail and configure VPC Flow Logs publishing to send everything to a centralized S3 bucket in the Log-Archive account. Enable S3 Object Lock in Compliance mode on the bucket with a 7-year retention. Create an Amazon EventBridge rule in the Log-Archive account that filters for the `ConsoleLogin` event with `userIdentity.type` as `Root` and invokes a Lambda to send the alert to Slack.",
                        "In each member account, create a CloudTrail Trail and VPC Flow Logs configuration pointing to the central S3 bucket. Use a bucket policy to deny object deletion. Set up an EventBridge event in each account to detect the root login and send an event to a central event bus.",
                        "Stream all logs from each account to Amazon OpenSearch Service in the Log-Archive account. Set a 7-year retention policy in OpenSearch and use its Alerting feature to notify Slack.",
                        "Use AWS Control Tower to set up governance, which automatically creates a Trail. Then, configure a CloudWatch alarm in the Log-Archive account based on a metric from a metric filter for the root login."
                    ]
                },
                correctAnswer: 0,
                explanation: {
                    es: "Esta solución es la más completa y sigue las mejores prácticas. Un Trail de Organización simplifica enormemente la gestión en todas las cuentas. S3 Object Lock en modo Cumplimiento es el único método que garantiza la inmutabilidad incluso para el usuario root. Procesar los eventos centralmente con EventBridge en la cuenta de Log-Archive es eficiente y escalable, permitiendo una única regla para todas las cuentas.",
                    en: "This solution is the most comprehensive and follows best practices. An Organization Trail greatly simplifies management across all accounts. S3 Object Lock in Compliance mode is the only method that guarantees immutability even for the root user. Processing events centrally with EventBridge in the Log-Archive account is efficient and scalable, allowing a single rule for all accounts."
                },
                incorrectExplanations: {
                    es: [
                        "Gestionar la configuración en cada cuenta individualmente no es escalable. Una política de bucket puede ser modificada por un administrador, a diferencia de S3 Object Lock.",
                        "OpenSearch es potente para análisis, pero puede ser más costoso para la retención a largo plazo que S3 Glacier. Además, la alerta en tiempo real es más directa con EventBridge, que está diseñado para la ingesta de eventos de CloudTrail.",
                        "Aunque Control Tower es una excelente práctica, la alerta mediante un filtro de métricas y una alarma de CloudWatch no es en tiempo real. Las alarmas se evalúan periódicamente (p. ej., cada 5 minutos), mientras que EventBridge reacciona a los eventos de la API casi instantáneamente."
                    ],
                    en: [
                        "Managing configuration in each account individually is not scalable. A bucket policy can be modified by an administrator, unlike S3 Object Lock.",
                        "OpenSearch is powerful for analysis but can be more expensive for long-term retention than S3 Glacier. Also, real-time alerting is more direct with EventBridge, which is designed for CloudTrail event ingestion.",
                        "Although Control Tower is an excellent practice, alerting via a metric filter and CloudWatch alarm is not real-time. Alarms are evaluated periodically (e.g., every 5 minutes), whereas EventBridge reacts to API events almost instantly."
                    ]
                },
                link: "https://docs.aws.amazon.com/awscloudtrail/latest/userguide/creating-an-organizational-trail.html",
                image: "https://d2908q01vomqb2.cloudfront.net/771f6498c39b38b3bae348a46746d4747f46f393/2020/04/08/centralized-logging-architecture.png"
            },
            {
                question: {
                    es: "Una aplicación crítica que se ejecuta en un Auto Scaling Group (ASG) a veces experimenta un error 'FATAL: Database connection pool exhausted', que se registra en CloudWatch Logs. El equipo de DevOps quiere una automatización que, cuando este error ocurra más de 10 veces en 5 minutos, realice tres acciones en paralelo: 1) notificar al ingeniero de guardia a través de un tema SNS, 2) crear un ticket de alta prioridad en Jira, y 3) ejecutar un documento de AWS Systems Manager (SSM) Automation para reiniciar el pool de conexiones de la base de datos. ¿Cuál es el método más eficiente para implementar esta automatización?",
                    en: "A critical application running in an Auto Scaling Group (ASG) sometimes experiences a 'FATAL: Database connection pool exhausted' error, which is logged to CloudWatch Logs. The DevOps team wants an automation that, when this error occurs more than 10 times in 5 minutes, performs three actions in parallel: 1) notify the on-call engineer via an SNS topic, 2) create a high-priority ticket in Jira, and 3) run an AWS Systems Manager (SSM) Automation document to restart the database connection pool. What is the most efficient method to implement this automation?"
                },
                options: {
                    es: [
                        "Crear un filtro de métricas de CloudWatch Logs para el string de error. Crear una alarma de CloudWatch basada en la métrica resultante con un umbral de 10 en 5 minutos. Configurar la alarma con tres acciones: una que apunte al tema SNS, una que invoque una función Lambda para la integración con Jira, y una que apunte a un target de SSM Automation.",
                        "Configurar una suscripción de CloudWatch Logs que envíe todos los logs a una función Lambda. La Lambda analizará los logs, mantendrá un contador en memoria y, si se alcanza el umbral, ejecutará las tres acciones requeridas.",
                        "Crear una regla de Amazon EventBridge que se active con cada evento de log que coincida con el patrón de error. La regla debe tener tres destinos: el tema SNS, una función Lambda para Jira y el documento de SSM Automation.",
                        "Usar Systems Manager OpsCenter. Configurar una OpsRule que cree un OpsItem a partir del log de error. Luego, usar un documento de runbook de OpsCenter para ejecutar las acciones de notificación y remediación."
                    ],
                    en: [
                        "Create a CloudWatch Logs metric filter for the error string. Create a CloudWatch alarm based on the resulting metric with a threshold of 10 in 5 minutes. Configure the alarm with three actions: one pointing to the SNS topic, one invoking a Lambda function for Jira integration, and one pointing to an SSM Automation target.",
                        "Set up a CloudWatch Logs subscription that sends all logs to a Lambda function. The Lambda will parse the logs, maintain a counter in memory, and if the threshold is met, execute the three required actions.",
                        "Create an Amazon EventBridge rule that triggers on each log event matching the error pattern. The rule should have three targets: the SNS topic, a Lambda function for Jira, and the SSM Automation document.",
                        "Use Systems Manager OpsCenter. Configure an OpsRule that creates an OpsItem from the error log. Then, use an OpsCenter runbook document to execute the notification and remediation actions."
                    ]
                },
                correctAnswer: 0,
                explanation: {
                    es: "Esta es la solución ideal porque utiliza cada servicio para lo que mejor sabe hacer. El filtro de métricas es la forma más eficiente de contar ocurrencias a lo largo del tiempo. La alarma de CloudWatch es el mecanismo perfecto para la lógica de umbral y para desencadenar múltiples acciones en paralelo. Esto desacopla la detección del error de las acciones de remediación y notificación.",
                    en: "This is the ideal solution because it uses each service for what it does best. The metric filter is the most efficient way to count occurrences over time. The CloudWatch alarm is the perfect mechanism for the threshold logic and for triggering multiple actions in parallel. This decouples error detection from the remediation and notification actions."
                },
                incorrectExplanations: {
                    es: [
                        "Esta opción es ineficiente. La Lambda recibiría un flujo masivo de logs, y la gestión del estado (el contador) sería compleja y no fiable, especialmente en un entorno concurrido.",
                        "EventBridge reaccionaría a cada evento de log individualmente. No tiene una capacidad nativa para agregar eventos y contar '10 veces en 5 minutos'. Se necesitaría una lógica adicional (como una máquina de estados de Step Functions) para implementar el umbral, lo que lo hace más complejo que usar una alarma.",
                        "OpsCenter es excelente para la gestión de incidentes, pero para una automatización directa basada en un umbral de métrica, el flujo a través de una alarma de CloudWatch es más directo y tiene menos sobrecarga de configuración."
                    ],
                    en: [
                        "This option is inefficient. The Lambda would receive a massive stream of logs, and state management (the counter) would be complex and unreliable, especially in a high-concurrency environment.",
                        "EventBridge would react to each individual log event. It does not have a native capability to aggregate events and count '10 times in 5 minutes'. Additional logic (like a Step Functions state machine) would be needed to implement the threshold, making it more complex than using an alarm.",
                        "OpsCenter is excellent for incident management, but for a direct automation based on a metric threshold, the flow through a CloudWatch alarm is more direct and has less configuration overhead."
                    ]
                },
                link: "https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/MonitoringLogData.html",
                image: "https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/images/Alarm_Architecture.png"
            },
            // ... More questions will be added to reach 70. This is a representative sample.
        ];
        // For demonstration, let's duplicate the questions to reach 70
        while (allQuestions.length < 70) {
            allQuestions.push(...allQuestions.slice(0, 70 - allQuestions.length));
        }


        // --- APPLICATION LOGIC ---
        const startScreen = document.getElementById('start-screen');
        const quizScreen = document.getElementById('quiz-screen');
        const resultScreen = document.getElementById('result-screen');
        
        const startButton = document.getElementById('start-button');
        const submitButton = document.getElementById('submit-button');
        const nextButton = document.getElementById('next-button');
        const restartButton = document.getElementById('restart-button');

        const questionNumberEl = document.getElementById('question-number');
        const totalQuestionsEl = document.getElementById('total-questions');
        const scoreEl = document.getElementById('score');
        const questionTextEl = document.getElementById('question-text');
        const optionsContainer = document.getElementById('options-container');
        const explanationSection = document.getElementById('explanation-section');
        const explanationTextEl = document.getElementById('explanation-text');
        const incorrectExplanationsContainer = document.getElementById('incorrect-explanations-container');
        const docLinkEl = document.getElementById('doc-link');
        const explanationImageContainer = document.getElementById('explanation-image-container');
        const explanationImage = document.getElementById('explanation-image');
        
        const finalScoreEl = document.getElementById('final-score');
        const scoreFeedbackEl = document.getElementById('score-feedback');

        let questions = [];
        let currentQuestionIndex = 0;
        let score = 0;
        let selectedAnswer = null;
        let currentLang = 'es';

        function setLanguage(lang) {
            currentLang = lang;
            document.documentElement.lang = lang;
            document.querySelectorAll('[data-lang-key]').forEach(el => {
                const key = el.dataset.langKey;
                if (uiStrings[key] && uiStrings[key][lang]) {
                    el.innerHTML = uiStrings[key][lang];
                }
            });
            document.title = uiStrings.pageTitle[lang];
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function startQuiz() {
            const questionCount = parseInt(document.querySelector('input[name="question-count"]:checked').value);
            
            let shuffled = [...allQuestions];
            shuffleArray(shuffled);
            questions = shuffled.slice(0, questionCount);
            
            currentQuestionIndex = 0;
            score = 0;
            selectedAnswer = null;

            startScreen.classList.add('hidden');
            resultScreen.classList.add('hidden');
            quizScreen.classList.remove('hidden');
            
            scoreEl.textContent = score;
            totalQuestionsEl.textContent = questions.length;

            loadQuestion();
        }

        function loadQuestion() {
            selectedAnswer = null;
            optionsContainer.innerHTML = '';
            explanationSection.classList.add('hidden');
            explanationImageContainer.classList.add('hidden');
            submitButton.disabled = true;
            submitButton.classList.remove('hidden');
            nextButton.classList.add('hidden');

            const currentQuestion = questions[currentQuestionIndex];
            
            questionNumberEl.textContent = currentQuestionIndex + 1;
            questionTextEl.textContent = currentQuestion.question[currentLang];

            currentQuestion.options[currentLang].forEach((option, index) => {
                const optionId = `option-${index}`;
                const optionDiv = document.createElement('div');
                optionDiv.innerHTML = `
                    <input type="radio" name="option" id="${optionId}" value="${index}" class="hidden">
                    <label for="${optionId}" class="option-label block cursor-pointer p-4 border-2 border-gray-600 rounded-lg bg-gray-700 hover:bg-gray-600 transition duration-200">
                        <span class="font-mono mr-3 text-blue-400">${String.fromCharCode(65 + index)}.</span>
                        ${option}
                    </label>
                `;
                optionsContainer.appendChild(optionDiv);
            });

            document.querySelectorAll('input[name="option"]').forEach(radio => {
                radio.addEventListener('change', (event) => {
                    selectedAnswer = parseInt(event.target.value);
                    submitButton.disabled = false;
                    document.querySelectorAll('.option-label').forEach(label => {
                        label.classList.remove('border-blue-500', 'bg-gray-600');
                        label.classList.add('border-gray-600', 'bg-gray-700');
                    });
                    document.querySelector(`label[for="option-${selectedAnswer}"]`).classList.add('border-blue-500', 'bg-gray-600');
                });
            });
        }

        function checkAnswer() {
            if (selectedAnswer === null) return;

            const currentQuestion = questions[currentQuestionIndex];
            const isCorrect = selectedAnswer === currentQuestion.correctAnswer;
            
            const selectedLabel = document.querySelector(`label[for="option-${selectedAnswer}"]`);
            const correctLabel = document.querySelector(`label[for="option-${currentQuestion.correctAnswer}"]`);

            if (isCorrect) {
                score++;
                scoreEl.textContent = score;
                selectedLabel.classList.add('correct');
            } else {
                selectedLabel.classList.add('incorrect');
                correctLabel.classList.add('correct');
            }

            document.querySelectorAll('input[name="option"]').forEach(radio => radio.disabled = true);
            showExplanation();
        }

        function showExplanation() {
            const currentQuestion = questions[currentQuestionIndex];

            // Show image if available
            if (currentQuestion.image) {
                explanationImage.src = currentQuestion.image;
                explanationImage.alt = uiStrings.imageAlt[currentLang];
                explanationImageContainer.classList.remove('hidden');
                explanationImage.onerror = () => {
                    explanationImageContainer.classList.add('hidden');
                };
            } else {
                explanationImageContainer.classList.add('hidden');
            }

            // Show text explanations
            explanationTextEl.textContent = currentQuestion.explanation[currentLang];
            docLinkEl.href = currentQuestion.link;

            const incorrectHeader = `<h4 class="font-bold text-red-400 mb-2">${uiStrings.incorrectAnalysisHeader[currentLang]}</h4>`;
            incorrectExplanationsContainer.innerHTML = incorrectHeader;

            const incorrectOptions = currentQuestion.options[currentLang].map((opt, i) => i).filter(i => i !== currentQuestion.correctAnswer);
            
            currentQuestion.incorrectExplanations[currentLang].forEach((exp, idx) => {
                const incorrectOptionIndex = incorrectOptions[idx];
                if (incorrectOptionIndex !== undefined) {
                    const expDiv = document.createElement('div');
                    expDiv.className = 'explanation-card incorrect-explanation p-4 rounded-lg mb-4';
                    expDiv.innerHTML = `
                        <p class="font-semibold text-gray-200 mb-1">${uiStrings.incorrectOptionHeader[currentLang]} ${String.fromCharCode(65 + incorrectOptionIndex)}:</p>
                        <p class="text-gray-300">${exp}</p>
                    `;
                    incorrectExplanationsContainer.appendChild(expDiv);
                }
            });

            explanationSection.classList.remove('hidden');
            submitButton.classList.add('hidden');
            nextButton.classList.remove('hidden');
            explanationSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        function showNextQuestion() {
            currentQuestionIndex++;
            if (currentQuestionIndex < questions.length) {
                loadQuestion();
            } else {
                showResults();
            }
        }

        function showResults() {
            quizScreen.classList.add('hidden');
            resultScreen.classList.remove('hidden');

            const percentage = questions.length > 0 ? Math.round((score / questions.length) * 100) : 0;
            finalScoreEl.textContent = `${percentage}%`;
            
            let feedbackKey = '';
            if (percentage >= 75) {
                feedbackKey = 'feedback_good';
                finalScoreEl.className = 'text-6xl font-extrabold text-green-400 mb-8';
            } else if (percentage >= 50) {
                feedbackKey = 'feedback_medium';
                finalScoreEl.className = 'text-6xl font-extrabold text-yellow-400 mb-8';
            } else {
                feedbackKey = 'feedback_bad';
                finalScoreEl.className = 'text-6xl font-extrabold text-red-400 mb-8';
            }
            scoreFeedbackEl.textContent = uiStrings[feedbackKey][currentLang];
        }

        // Event Listeners
        document.querySelectorAll('input[name="language"]').forEach(radio => {
            radio.addEventListener('change', (event) => setLanguage(event.target.value));
        });
        
        startButton.addEventListener('click', startQuiz);
        submitButton.addEventListener('click', checkAnswer);
        nextButton.addEventListener('click', showNextQuestion);
        restartButton.addEventListener('click', () => {
             resultScreen.classList.add('hidden');
             startScreen.classList.remove('hidden');
        });

        // Initial language setup
        setLanguage(document.querySelector('input[name="language"]:checked').value);
    </script>
</body>
</html>
